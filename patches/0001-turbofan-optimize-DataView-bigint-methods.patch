From e698b39d107e9bc9efede704ad0aab780e4ce908 Mon Sep 17 00:00:00 2001
From: snek <snek@chromium.org>
Date: Tue, 23 Jul 2024 11:24:36 -0700
Subject: [PATCH] [turbofan] optimize DataView bigint methods

Adds turbo lowering for DataView bigint methods, based on
lowering for bigint TypedArrays.

Bug: 42204197
Change-Id: I00eada0aeea1b9b8d1990c611cb6c5b6638b145e
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/5723179
Commit-Queue: snek <snek@chromium.org>
Reviewed-by: Darius Mercadier <dmercadier@chromium.org>
Cr-Commit-Position: refs/heads/main@{#95263}
---
 src/compiler/js-call-reducer.cc       | 34 +++++++++++++++++++++++----
 test/mjsunit/compiler/dataview-get.js | 34 +++++++++++++++++++++++++++
 test/mjsunit/compiler/dataview-set.js | 34 +++++++++++++++++++++++----
 3 files changed, 93 insertions(+), 9 deletions(-)

diff --git a/src/compiler/js-call-reducer.cc b/src/compiler/js-call-reducer.cc
index e3d50277172..42c7d7d0374 100644
--- a/src/compiler/js-call-reducer.cc
+++ b/src/compiler/js-call-reducer.cc
@@ -4971,6 +4971,12 @@ Reduction JSCallReducer::ReduceJSCall(Node* node,
     case Builtin::kDataViewPrototypeGetFloat64:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalFloat64Array);
+    case Builtin::kDataViewPrototypeGetBigInt64:
+      return ReduceDataViewAccess(node, DataViewAccess::kGet,
+                                  ExternalArrayType::kExternalBigInt64Array);
+    case Builtin::kDataViewPrototypeGetBigUint64:
+      return ReduceDataViewAccess(node, DataViewAccess::kGet,
+                                  ExternalArrayType::kExternalBigUint64Array);
     case Builtin::kDataViewPrototypeSetUint8:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalUint8Array);
@@ -4995,6 +5001,12 @@ Reduction JSCallReducer::ReduceJSCall(Node* node,
     case Builtin::kDataViewPrototypeSetFloat64:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalFloat64Array);
+    case Builtin::kDataViewPrototypeSetBigInt64:
+      return ReduceDataViewAccess(node, DataViewAccess::kSet,
+                                  ExternalArrayType::kExternalBigInt64Array);
+    case Builtin::kDataViewPrototypeSetBigUint64:
+      return ReduceDataViewAccess(node, DataViewAccess::kSet,
+                                  ExternalArrayType::kExternalBigUint64Array);
     case Builtin::kTypedArrayPrototypeByteLength:
       return ReduceArrayBufferViewByteLengthAccessor(node, JS_TYPED_ARRAY_TYPE);
     case Builtin::kTypedArrayPrototypeByteOffset:
@@ -8403,6 +8415,12 @@ Reduction JSCallReducer::ReduceDataViewAccess(Node* node, DataViewAccess access,
   Node* receiver = n.receiver();
   Node* offset = n.ArgumentOr(0, jsgraph()->ZeroConstant());
   Node* value = nullptr;
+
+  if (!Is64() && (element_type == kExternalBigInt64Array ||
+                  element_type == kExternalBigUint64Array)) {
+    return NoChange();
+  }
+
   if (access == DataViewAccess::kSet) {
     value = n.ArgumentOrUndefined(1, jsgraph());
   }
@@ -8465,10 +8483,18 @@ Reduction JSCallReducer::ReduceDataViewAccess(Node* node, DataViewAccess access,
 
   // Coerce {value} to Number.
   if (access == DataViewAccess::kSet) {
-    value = effect = graph()->NewNode(
-        simplified()->SpeculativeToNumber(NumberOperationHint::kNumberOrOddball,
-                                          p.feedback()),
-        value, effect, control);
+    if (element_type == kExternalBigInt64Array ||
+        element_type == kExternalBigUint64Array) {
+      value = effect =
+          graph()->NewNode(simplified()->SpeculativeToBigInt(
+                               BigIntOperationHint::kBigInt, p.feedback()),
+                           value, effect, control);
+    } else {
+      value = effect = graph()->NewNode(
+          simplified()->SpeculativeToNumber(
+              NumberOperationHint::kNumberOrOddball, p.feedback()),
+          value, effect, control);
+    }
   }
 
   // We need to retain either the {receiver} itself or it's backing
diff --git a/test/mjsunit/compiler/dataview-get.js b/test/mjsunit/compiler/dataview-get.js
index 33e2ff14182..0bd3490eda2 100644
--- a/test/mjsunit/compiler/dataview-get.js
+++ b/test/mjsunit/compiler/dataview-get.js
@@ -53,6 +53,22 @@ function readFloat64(offset, little_endian) {
   return dataview.getFloat64(offset, little_endian);
 }
 
+function readBigInt64Handled(offset, little_endian) {
+  try {
+    return dataview.getBigInt64(offset, little_endian);
+  } catch (e) {
+    return e;
+  }
+}
+
+function readBigUint64Handled(offset, little_endian) {
+  try {
+    return dataview.getBigUint64(offset, little_endian);
+  } catch(e) {
+    return e;
+  }
+}
+
 function warmup(f) {
   %PrepareFunctionForOptimization(f);
   f(0);
@@ -132,6 +148,24 @@ assertEquals(b4, readFloat64(16));
 dataview.setFloat64(16, b4, true);
 assertEquals(b4, readFloat64(16, true));
 
+// TurboFan valid getBigInt64.
+let b5 = -0x12345678912345n;
+dataview.setBigInt64(16, b5);
+warmup(readBigInt64Handled);
+assertOptimized(readBigInt64Handled);
+assertEquals(b5, readBigInt64Handled(16));
+dataview.setBigInt64(16, b5, true);
+assertEquals(b5, readBigInt64Handled(16, true));
+
+// TurboFan valid getBigUint64.
+let b6 = 0x12345678912345n;
+dataview.setBigUint64(16, b6);
+warmup(readBigUint64Handled);
+assertOptimized(readBigUint64Handled);
+assertEquals(b6, readBigUint64Handled(16));
+dataview.setBigUint64(16, b6, true);
+assertEquals(b6, readBigUint64Handled(16, true));
+
 // TurboFan out of bounds reads deopt.
 assertOptimized(readInt8Handled);
 assertInstanceof(readInt8Handled(24), RangeError);
diff --git a/test/mjsunit/compiler/dataview-set.js b/test/mjsunit/compiler/dataview-set.js
index 4ef6d9a583c..a207e0ea7f7 100644
--- a/test/mjsunit/compiler/dataview-set.js
+++ b/test/mjsunit/compiler/dataview-set.js
@@ -43,13 +43,21 @@ function writeFloat64(offset, value, little_endian) {
   dataview.setFloat64(offset, value, little_endian);
 }
 
-function warmup(f) {
+function writeBigInt64(offset, value, little_endian) {
+  dataview.setBigInt64(offset, value, little_endian);
+}
+
+function writeBigUint64(offset, value, little_endian) {
+  dataview.setBigUint64(offset, value, little_endian);
+}
+
+function warmup(f, v = 0) {
   %PrepareFunctionForOptimization(f);
-  f(0, 0);
-  f(0, 1);
+  f(0, v++);
+  f(0, v++);
   %OptimizeFunctionOnNextCall(f);
-  f(0, 2);
-  f(0, 3);
+  f(0, v++);
+  f(0, v++);
 }
 
 // TurboFan valid setUint8.
@@ -118,6 +126,22 @@ assertEquals(b4, dataview.getFloat64(8));
 writeFloat64(8, b4, true);
 assertEquals(b4, dataview.getFloat64(8, true));
 
+// TurboFan valid setBigInt64.
+warmup(writeBigInt64, 0n);
+assertOptimized(writeBigInt64);
+writeBigInt64(0, -2401053088876216593n);
+assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0));
+writeBigInt64(0, -1171307680053154338n, true);
+assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0));
+
+// TurboFan valid setBigUint64.
+warmup(writeBigUint64, 0n);
+assertOptimized(writeBigUint64);
+writeBigUint64(0, 0xdeadbeefdeadbeefn);
+assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0));
+writeBigUint64(0, 0xdeadbeefdeadbeefn, true);
+assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0, true));
+
 // TurboFan out of bounds read, deopt.
 assertOptimized(writeInt8Handled);
 assertInstanceof(writeInt8Handled(24, 0), RangeError);
-- 
2.45.2

